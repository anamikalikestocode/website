<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>here is everything</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&family=Inter:wght@300;400&display=swap" rel="stylesheet">
</head>
<body class="landing-page">
    <main class="landing">
        <h1 class="tagline" id="tagline">here's a bunch of stuff i think and will stand by for the next 3 months</h1>
        <nav class="nav-links">
            <a href="writings/">writings</a>
            <a href="thoughts/">thoughts</a>
            <a href="me.html">me</a>
        </nav>
        <p class="signature">â€” anamika</p>
    </main>

    <script>
        // Text scramble effect
        class TextScramble {
            constructor(el) {
                this.el = el;
                this.chars = 'abcdefghijklmnopqrstuvwxyz';
                this.update = this.update.bind(this);
            }

            setText(newText) {
                const oldText = this.el.innerText;
                const length = Math.max(oldText.length, newText.length);
                const promise = new Promise((resolve) => this.resolve = resolve);
                this.queue = [];

                for (let i = 0; i < length; i++) {
                    const from = oldText[i] || '';
                    const to = newText[i] || '';
                    const start = Math.floor(Math.random() * 40);
                    const end = start + Math.floor(Math.random() * 40);
                    this.queue.push({ from, to, start, end });
                }

                cancelAnimationFrame(this.frameRequest);
                this.frame = 0;
                this.update();
                return promise;
            }

            update() {
                let output = '';
                let complete = 0;

                for (let i = 0, n = this.queue.length; i < n; i++) {
                    let { from, to, start, end, char } = this.queue[i];

                    if (this.frame >= end) {
                        complete++;
                        output += to;
                    } else if (this.frame >= start) {
                        if (!char || Math.random() < 0.28) {
                            char = this.randomChar();
                            this.queue[i].char = char;
                        }
                        output += char;
                    } else {
                        output += from;
                    }
                }

                this.el.innerText = output;

                if (complete === this.queue.length) {
                    this.resolve();
                } else {
                    this.frameRequest = requestAnimationFrame(this.update);
                    this.frame++;
                }
            }

            randomChar() {
                return this.chars[Math.floor(Math.random() * this.chars.length)];
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            const taglineEl = document.getElementById('tagline');
            const finalText = taglineEl.innerText;
            const fx = new TextScramble(taglineEl);

            // Start with empty and scramble in
            taglineEl.innerText = '';
            setTimeout(() => {
                fx.setText(finalText).then(() => {
                    // After scramble completes, wrap each word in a span for individual hover
                    const words = finalText.split(' ');
                    taglineEl.innerHTML = words.map(word =>
                        `<span class="tagline-word">${word}</span>`
                    ).join(' ');
                });
            }, 300);
        });
    </script>
</body>
</html>
